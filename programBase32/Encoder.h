/**
* @file Encoder.h
* @author Авдонин А.Д.
* @version 1.0
* @copyright ИБСТ ПГУ
*/
#pragma once
#include "Alphabet.h"
#include <vector>
///@brief Кодирует данные в Base32
class Encoder: protected Alphabets
{
private:
///@brief Ключ Base32
///@details Ключ Base32 равен 5, так как при Base32 используется набор из 32 символов, каждый из которых может быть представлен 5 битами.
    const int b32key = 5;
///@brief Хранит результат кодирования, а также предназначен для конструктора строкой.
    string stroka;
    /**@brief Битовые операции в Base32.
     * @details
     * @param buffer - представление символов в двоичном виде.
     * @param bitCount - количество бит в строке. Максимольное значение - 40 бит. Минимальное - 8 бит.
     * @details Пока количество бит не равно 0, происходит процесс "отщипления битов" по ключу Base32, который равен 5.
     * <br>Затем полученное число производит побитовую операции "And" c числом 31, так как в алфавите Base32 - 32 основных символа.
     * <br>Побитовая операция "And" производится с числом 31, так как индексация в языке с++ начинается с 0.
     * <br>Полученные числа переводятся  в символы алфавита Base32.
     * <br>Эти числа используются как индексы "массива" и записываются в vector <char>.
     * @return vector <char> с символами, которые являются основными символами Base32.
     * */
    vector<char> B32bit_operations(unsigned long long int &buffer, int &bitCount);
    /**@brief Добавление символа "=" в Base.
     * @details
     * @param res - vector <char> с символами, которые являются основными символами Base32.
     * @details Если при кодировании получась строка, у которой количество бит кратно 5, то символ "=" не добоавляется.
     * <br>В противном случае в строку добавляются "нулевые" биты до тех пор, пока общее число бит не станет делится на ключ Base32, который равен 5.
     * <br>Тогда в кодированную строку добавляется символ "=" столько раз, сколько было добавлено так называемх "нулевых бит".
     * <p>Количество добавления считается по слелующей формуле: <b>Count_EQUAL= (8 - (dlina % 8)) % 8 </b>, где dlina - количество символов в кодированной строке.</p>
     * @return vector <char> с символами в формате Base32.
     * */
    vector<char> Base_equally (vector <char> res); // = в Base

public:
    /**@brief перегрузка оператора []
     * @param index - целочисленное число
     * @return ссылку на тип "char", то есть по индеку в строке возвращает символ.
     * */
    char& operator[] (const int index); // перегрузка []
    ///@brief Конструктор по умолчанию
    Encoder () = default;
    ///@brief Деструктор по умолчанию
    ~Encoder() = default;
    /**@brief Конструктор строкой
     * @param строка Си++
     * @details Узнаём размер строки, которая пришла на вход.<br>  Меняем размер атрибута "stroka" для того, чтобы не было ошибок с памятью. <br>
     *  Далее в данный private атрибут "stroka" записываем строку, которая пришла на вход.
     * */
    Encoder (const string str);
    /**@brief Перугрзка оператора сравнение "=="
     * @param left - ссылка на левый операнд типа "Encoder"
     * @param right - ссылка на правый операнд типа "Encoder"
     * @details С помощью обычного условия сравнивается private атрибут "stroka" у обоих операндов.
     * @return значение "true", если условие выполнено успешно, и значение "false" в противном случае.
     * */
    friend bool operator == (const Encoder & left, const Encoder & right);
    /**@brief Кодирование любых данных в Base32.
     * @param data - строка Си++.
     * @details <p>Узнаётся длина строки, которая пришла на вход. Далее создаётся <b>vector <unsigned char></b> и в него записываются символы строки. <br>
     * Это делается для того, чтобы наш метод мог кодировать строку, в которой присутствуют символы русского алфавита.</p>
     * <p>Затем в цикле каждые 5 байт( или же меньше в зависимости от размера строки, которая пришла на вход) строки переводятся в двоичный код и <br>записываются 
     * в переменную <b>"buffer" типа "unsigned long long int"</b>. <br>Так как данный процесс происходит в цикле, то
     * в переменную <b>"buffer"</b> может записыться максимум - 40 бит,а минимум - 8.</p>
     * <p>Затем испольузется инкопсулированнай метод из "private" секции <b>"B32bit_operations"</b>.<br>
     * В итоге после выхода из цикла в vector-e <char> хранятся основные символы Base32 кодированной строки.<br>
     * Затем к данному вектору пременяется  инкопсулированный метод из "private" секции <b>"Base_equally"</b>, который добавляет в конец кодированной строки <br>
     * символ "=" при необходимости.</p> 
     * <p>Далее в атрибут класса "Encoder" c именем "stroka" записывается содержимое символьного вектора, в котором хранятся символы кодированной строки.</p>
     * @return кодировання строка типа "Encoder"
     * */
    Encoder base32Encode(string data); // кодированиe
    /**@brief Перугрзка оператора побитового сдвига "<<" для вывода
    * @param out - ссылка на операнд типа "ostream"
    * @param a - ссылка на операнд типа "Encoder"
    * @details  Внутри функции operator<< происходит вывод строки, на которую указывает атрибут "a" нашего класса "Encoder",
    *в поток, задаваемый параметром " out".
    * @return ссылочный тип "ostream" на поток вывода.
    * */
    friend ostream & operator<<(ostream &out, const Encoder &a); // перегрузка <<
};
